## 设计动机

操作系统通常需要为用户态的程序提供内存管理功能，因此 VM area 库（下称「本程序库」）希望为不同的操作系统提供跨平台的 **用户态内存管理** 功能实现。本程序库有以下假设：

- 用户态的内存空间与内核态内存空间分离
- 用户态程序以块为单位申请内存，每块有不同的内存权限定义，同一块内的内存权限定义是相同的
- 所有平台上都有内存权限管理（R / W / X）功能，并且允许任意一块内存的权限为空（不可访问）

即使最终的操作系统不符合这些假设（如用户态与内核态共用内存空间），本程序库仍能够提供内存管理功能，但需要进行一定的插桩修改（如让内核的内存空间也用本程序库进行管理）。

## 理念

将用户态内存空间划分为块，称为 **内存区域**（VM area）。每个内存区域可以定义不同的属性，如页面权限（R / W / X），以及操作系统自己定义的属性（区域名，相关联的文件号等）。

- 支持在任意位置分配一个内存区域（只要该区域空闲）。
- 支持由系统寻找一个指定大小的空闲空间用于内存分配。
- 支持修改任意内存区域的属性，以及释放内存区域。
- 支持内存区域向两端扩展和压缩，不支持内存区域的合并和拆分。
- （可选地）支持对整个进程的内存布局加锁和解锁，实现内存操作的原子化。

提供对 **页面错误**（page fault）的支持。操作系统可以将任意内存区域标记为 **未初始化的**，并提供相应的页面错误处理程序（page fault handler）。在相应的页面发生访问异常时，将由本程序库调用页面错误处理程序。_操作系统也可以主动卸载已初始化的内存，将其还原为未初始化状态（待定）。_

## 数据结构代码示例

```rust
struct VmArea {
    // VM area 对应的 **虚拟地址** 区间：[start, end)
    start: usize,
    end: usize,

    // 相应的事件处理函数
    ops: &'static VmOperations,
    
    // 自定义数据域
    data: *mut (),
}

struct VmOperations {
    /// 当某个内存地址发生 page fault 时
    page_fault: fn(&mut VmArea, usize),
    /// 当某个 VmArea 被移除时
    unmap: fn(&mut VmArea),
}
```
